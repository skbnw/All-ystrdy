headline,mainEntityOfPage,image,datePublished,dateModified,author,media_en,media_jp,str_count,body,images,external_links
同じ箱でも中身が違う（PC Watch）,https://news.yahoo.co.jp/articles/38a80620977cec68d3a97829c0f0b6c87892b29b,https://newsatcl-pctr.c.yimg.jp/t/amd-img/20240921-00000014-imppcw-000-1-view.jpg?exp=10800,2024-09-21T06:11:00+09:00,2024-09-21T06:11:00+09:00,PC Watch,imppcw,PC Watch,3142,"\n写真：PC Watch\n見かけは同じなのにその中身が違う。パワーユーザーにとっては当たり前の話でも、コンシューマーにとっては難解な話だ。Quallcomm、AMD、Intelの三つ巴は、これからのPCという商品の売り方買い方にどんな影響をもたらすのだろう。そしてそれは近い将来のパーソナルコンピューティングにどんな影響を与えるのだろうか。\n\n■ デルからIntel版Copilot+ PC登場\n\n デルが都内のホテルで発表会を開催、「XPS 13(9350)」をお披露目した。最新CPUとして、インテルCore Ultra(シリーズ2)を搭載した製品で、2024年9月27日からフルカスタマイズモデルを販売開始予定だ。また、後日、一部構成の即納モデルも用意し、一部の量販店において11月下旬に販売を開始するという。\n\n XPS 13は13.4型のモニターを搭載した重量1.18kgの薄軽ノートPCだ。新製品だが、グラファイトカラーを選んだ場合、既存のXPS 13と見分けがつかないかもしれない。\n\n というのも、Copilot+ PCとして5月に発表されたXPS 13は、QualcommのSnapdragon X EliteシリーズのSoCを搭載していたが、今回のXPS 13はコードネームLunar Lakeで知られるCore Ultra シリーズ2を搭載している。アーキテクチャの異なるプロセッサーが同じ筐体に格納され、それぞれが強力なオンデバイスAI処理を実現する。\n\n また、11月にはMicrosoftのCopilot+ PCとして認定され、Windowsの各種AIアプリが無償でアクティベイトされ、Qualcomm Copilot+ PCと同等の環境になる。\n\n バッテリ駆動時間はデルの基準となるNetflixストリーミングを使ったバッテリのベンチマークで26時間を記録したという。Dellのラボで、ディスプレイの輝度を150cd/平方m(40%)に設定し、ワイヤレスを有効にした状態でWindows 11のNetflixアプリケーションを使用し、Netflixの1080pストリーミングコンテンツを連続再生してマークされた。ちなみに今回のCore Ultra シリーズ2搭載のXPS 13は、Snapdragon搭載のXPS 13よりバッテリ駆動時間が1時間短かい。24時間超の領域では1時間の違いはほぼ無意味だともいえるし、AIフル活用時のバッテリ駆動時間も気になるところだ。\n\n 参考販売価格は、Core Ultra 5 226V(16GB)、512GB SSD、フルHD液晶の構成で約26万円となっている。ほぼ同じ構成のSnapdragon XPS 13よりも約5万円高い価格設定だ。なお、Core Ultra 9搭載モデルは11月の登場となる。\n\n 発表会では実機でのデモンストレーションが披露された。このデモに使われた実機が現時点で日本に存在する唯一の筐体だという。\n\n■ まずはニッチな領域をカバーするシリーズ2SoC\n\n 発表会にはインテル株式会社の技術本部部長、工学博士の安生健一朗氏もゲストとして登壇、インテルCoreUltra(シリーズ2)の魅力を語った。\n\n Intelとしては基本的なPCとしての機能は進化し続けているし、同社は今後も、その進化が続くことを担保すると安生氏はいう。Core Ultraはシリーズ1からシリーズ2となり、P Coreのハイパースレッディングをやめ、面積/電力あたりの性能に最適化されたという。E CoreとP Coreでは、E Coreの進化が特に著しいそうだ。\n\n 電力優先のE Coreと処理優先のP Coreにスレッドを割り振るインテル・スレッド・ディレクターも進化、OSコンテインメント・ゾーンと呼ばれる制御ができるようになった。これは、OSとネゴシエーションすることで、アプリケーションごとにEコアとPコアの使い方を従来よりももっと明確なものにしていく。\n\n たとえば、最初E Coreにスケジューリングした処理を、パフォーマンスのデマンドが大きくなると同時にP Coreに移動したり、逆に、リソースがあればあるだけ使うTeamsのようなアプリは、絶対にP Coreを割り当てないようにすることで電力効率を高めるといったことができるようになった。\n\n オンライン会議などでTeamsを使うと、みるみるバッテリがなくなってしまうのを経験的に知っているユーザーは多いと思う。そういうことがなくなるというわけだ。\n\n IntelとしてはNPUにAI処理をまかせたから、GPUはお役御免とは考えていない。電力効率よりもとにかく速くという用途が求められる場合にはNPUよりもGPUの方が有利だからだ。デルも同様に、Core Ultraプロセッサーのシリーズ2は、モバイルコンピューティングで真価を発揮するものの、当面は、シリーズ1との棲み分けることになりそうだと考えているようだ。\n\n それでもAIが今後のパーソナルコンピューティングには欠かせないことは間違いない。だが、電力を確保しやすいデスクトップPCではGPUの力業でAI処理をした方がいい結果が得られそうだし、ノートPCでも、より高い性能を求めるワークステーション的な使い方を想定する場合には、高性能なGPUを併用し、シリーズ2のソリューションは選択肢としてありえないという判断も考えられる。\n\n こうしたことを統合すると、Core Ultra シリーズ2は、PC市場全体からすると、究めてニッチな領域をカバーする特別なSoCであるともいえる。そのニッチを請け負ったのがSnapdragonだったわけだが、Intelはそこをキャッチアップするつもりだ。\n\n■ コンピュータは何でも知っている\n\n 少なくとも、量販店頭などで、まるで同じように見えるノートPCがあったとして、片方がSnapdragon、片方がCore Ultra シリーズ2を搭載していたとして、販売員はどちらをどのように勧めるのだろうか。いや、販売員のみならず、ぼくらのような商売でも悩みどころだ。ここはまだ結論が出ないでいる。\n\n PCが一家に一台必要と叫ばれた当時、もしかしたら持ち出すかもしれないということで15.6型A4サイズノートPCが国民標準機のようになった。結局のところそのノートPCのほとんどは、実際に居宅から持ち出されることなくそのライフサイクルを終えた。\n\n でも、AIはそうはならないだろう。据置でもモバイルでもちゃんと役にたつ。分からないこと、知りたいことがあったらGoogleに聞けばいいことが新しい当たり前になったように、生成AIについては、人類の歴史の中で、コンピュータという響きに期待するものに、さらに近しい使い方として定着するだろう。テキストにしてもグラフィックスにしても、ノーコードで、しかも自然語で頼むだけで思ったことができるようになる。\n\n そのためにどのようなコンピュータリソースが求められるのか。今、デルが出荷しているノートPCのうち、半分近くがすでにNPU搭載機なのだそうだ。そして、現時点で、多くの実用的なAIサービスが有料で提供されていることを考えると、ハードウェア、ソフトウェアの初期投資だけで好きなだけ使えるオンデバイスAIは、これからのパーソナルコンピューティングに少なからぬ影響を与えることになりそうだ。\nPC Watch,山田 祥平",['https://newsatcl-pctr.c.yimg.jp/t/amd-img/20240921-00000014-imppcw-000-1-view.jpg?pri=l&w=640&h=360&exp=10800'],['https://news.yahoo.co.jp/articles/38a80620977cec68d3a97829c0f0b6c87892b29b/images/000']
【第60回】埃を被っているRaspberry Pi 4やミニPCをメディアサーバーとして活用する（PC Watch）,https://news.yahoo.co.jp/articles/5c2bc36acea521b3955a2cb94837f00b393fabd5,https://newsatcl-pctr.c.yimg.jp/t/amd-img/20240921-00000015-imppcw-000-1-view.jpg?exp=10800,2024-09-21T06:13:00+09:00,2024-09-21T06:13:00+09:00,PC Watch,imppcw,PC Watch,17101,"\n写真：PC Watch\nRasbperry PiやミニPCを活用していますか？買っただけで満足しちゃって放置していませんか？まさか電源すら入れていないってことはないですよね？\n【画像】デバイスは「Raspberry Pi 4」をOSは「Other general-purpose OS」から「Ubuntu」の「Ubuntu Server 24.04」で始まるものを選ぼう\nさて、今回はUbntuの記事とイベント用に購入し、その後ずっと放置されていた「Raspberry Pi 4」さんの供養を行なう。具体的にはJellyfinをインストールし、省電力メディアサーバーにしてしまおう。\n\n■ なんでRaspberry Piなの？今ならミニPCでも良くない？\n\n 一昔前までは「安く、低消費電力で、コンパクトなPC」と言えば、Raspberry Piを初めとするシングルボードコンピューター(SBC)がもてはやされていた。しかしながらそのRaspberry Piも性能があがるにつれて、価格も向上し、発熱も強くなり、電源周りもいろいろと気をつける必要が出てきている。\n\n さらにここ数年はさまざまなミニPCが登場し、小型PCとしてのRaspberry Piは「選択肢の1つ」でしかなくなった。特にWindowsを動かしたい層や、Steamを初めとしたゲームのうち、そこまで3D性能がいらないものが動いて欲しい層にとっては、ミニPCが有力な選択肢になりがちだ。\n\n もちろんRaspberry Pi自体に価値がなくなったわけではなく、少し高めの性能が欲しい組み込み機器のDIY、電子工作などのプロトタイピング、それらのための教育/学習など、本来の用途では十分に活躍している。そもそもRaspberry Piには豊富なGPIOピンやカメラコネクタなどが搭載されており、各種センサーやサーボなどの周辺デバイスを繋いでこそ真価を発揮するという考え方もある。\n\n だからと言って、Raspberry PiをミニPCっぽく使ってはいけないという理由もない。実際ケースの種類は豊富だし、サイズもコンパクトに収まる。依然として消費電力は小さいので常時動いてちょっとしたことを行なうサーバーに向いている。うまく設定してやればほぼファンレスな運用も可能だ。\n\n そしてなんといっても、ほとんどのミニPCに比較すると、ACアダプタは圧倒的に小さくできる。Ubuntuのリポジトリにあるパッケージのほぼすべてが、Raspberry Pi上でも動く。つまりRaspberry Piはご家庭内のLinuxサーバーには向いているのだ。\n\n と、いろいろ御託を並べたが、今回Raspberry Pi 4を元に説明するのは、手元で持て余していたからという理由だけだ。本記事で紹介する手順はRaspberry Pi 4ベースではあるが、メディアサーバーである「Jellyfin」そのものや、そのUbuntuへのインストール方法は、そのままミニPCでも適用できる。もちろんRaspberry Pi 5でも構わないし、その他のSBCでも動く可能性は高い。よって余っているマシンがあればRaspberry PiやミニPCに問わず試してみてほしい。\n\n■ メディアブラウザ「Jellyfin」\n\n Jellyfinはマルチプラットフォームに対応したメディアサーバーだ。手持ちの動画や音楽、写真の配信は元より、サービスが対応していればTVのライブ視聴なども行なえる。Jellyfinそのものはサーバーとして開発されており、プレーヤー側としてはWebブラウザや専用クライアント、Android/iOSのアプリ、ChromecastやスマートTVなどほとんどのデバイス向けのクライアントが用意されている。\n\n 再生速度の変更/全画面再生/PinP/プレイリスト/ハードウェアトランスコーディングなどなど、再生時に欲しい機能は一通りサポートしているし、マルチユーザーでのアカウント管理も可能だ。複数クライアント間で同時視聴できるSyncPlayなんて機能も存在する。\n\n 元々は「VideoBrowser」という名前のWindows向けソフトウェアとして開発が始まり、その後「MediaBrowser」、「Emby」と名前を変えて開発が続いているソフトウェアが元になっている。EmbyはもともとGPL 2.0で提供されていたが、2018年になって次のリリースから本格的にクローズドソースになるとアナウンスされたことなどを受けて、GPL版のEmbyをフォークして作られたのがJellyfinだ。\n\n 言語はC\n#を採用しているが\n、フレームワークとしては「.NET」を使っており、Ubuntu上はもちろんRaspberry PiのようなArm上のデバイスでも動作する。前述の通り豊富なクライアントソフトウェアが用意されているため、一般的なデバイスであれば再生環境に困ることはないだろう。\n\n ちなみにJellyfinは、Raspberry PiなどのSBCへのインストールは推奨していない。理由は単純で「性能が低い」からだ。特にハードウェアアクセラレーションについては、IntelなどのCPUに組み込まれているiGPUのそれに比較すると使える機能が少なかったり、インターフェイスが不明だったりすることも多いため、動画などをさまざまな解像度で描画するには向かないと考えておいたほうがいいだろう。ただし、今回はトランスコードが不要な音楽の配信を目的としている。利用する機能を限定する前提なら、Raspberry Piでも十分に動作する。\n\n■ Raspberry Pi 4にUbuntuをインストール\n\n まずはRaspberry Pi 4にUbuntuをインストールしよう。と言ってもデスクトップ版UbuntuのRaspberry Pi 5へのインストール方法はすでに第52回で紹介した。デスクトップ版のインストール方法については、Rasbperry Pi 4でもほぼ同じなのでそちらを参照して欲しい。\n\n 今回はメディアサーバーということでサーバー版をインストールしよう。また、Raspberry Pi 4にはM.2コネクターはないため、インストール先もUSBかSDカードかのどちらかになる。なお第41回でも説明した「UASプロトコル(USB Attached SCSI Protocol)」については、Raspberry Pi 4だといくつか懸念点があるようだ。まったく動かないというわけではないが、相性によっては性能が低下する可能性がある点にも注意しておこう。相性問題が発生した場合は、Ubuntu側でそのUSBストレージに対してUASプロトコルを無効化することになる。\n\n またメディアサーバーで配信するデータは、Ubuntuとは別のストレージにしておいたほうが何かあったときの取り回しはしやすい。こちらは容量が必要になるのでUSB接続のストレージになるだろう。\n\n ここまでの話を踏まえると、Ubuntuのインストールと起動方法として次のような選択肢が出てくる。\n\n・USBストレージを2台接続し、片方をUbuntuにする\n・USBストレージを1台接続し、UbuntuはmicroSDカードから起動する\n・USBストレージを1台接続し、Ubuntuはネットワークブートする\n\n ただしRaspberry Pi 4のUSBには次の制約が存在する。\n\n・4ポート合わせて1,200mAまで\n・4ポートで通信帯域も共有する\n・USB-SSD/UASには相性問題がある\n\n 一般的なmicroSDカードは遅いし壊れやすい。よってRaspberry Pi 4でOSを起動するならUSBストレージがよく使われる。実際デスクトップを動かすなら速度が出るUSBストレージを使いたくなるだろう。しかしながら今回はサーバー版であるため、そこまで大きなサイズのファイルを頻繁にアクセスすることはない。特に起動するプログラム自体は一度メモリにロードされてしまえば、microSDカードの遅さは気にならなくなる。そうなるとUSBの帯域はメディアサーバーのストレージアクセスに使いたいところだ。\n\n そのような事情もありRaspberry Pi 4の場合、UbuntuサーバーそのものはmicroSDカードにインストールしてしまうことも十分に意味がある。今回はmicroSDカードにUbuntuをインストールして、USBポートはJellyfinで配信するデータ専用のストレージにしてしまおう。\n\n Ubuntuのインストール方法は第52回と同じく「Raspberry Pi Imager」を使う。\n\n 一般的にサーバー運用する場合、なるべく「余計なソフトウェアはインストールしない」ことが鉄則だ。インストールされているソフトウェアが多いほどメンテナンスは煩雑になるし、対応しなければならない脆弱性も増える。NATの内側で運用するのであればある程度の緩さは許容されるものの、それでも手間がかからないにこしたことはない。よってデスクトップ版を使うよりはサーバー版を使うことを強くおすすめする。\n\n Raspberry Pi Imagerは「cloud-init」と呼ばれる初期設定システムをサポートしている。この設定画面でホスト名やユーザー名を入れておけば、起動直後に設定スクリプトが動作し、必要な設定を行ってくれるというわけだ。そうすることでディスプレイ/キーボードを用意しなくても、起動すればすぐに使えるようになる。\n\n さらに上記設定で「ホスト名.local」を設定しておくと、初回起動後に「avahi-daemon」パッケージをインストールしてくれる。これはLinuxで動くmDNS(Multicast DNS)機能で、いわゆるDNSがなくてもLAN内であれば「ホスト名.local」で名前解決できる仕組みだ。逐一サーバーのIPアドレスを把握しなくても良いので、ご家庭内のネットワークでカジュアルに提供するサービスにはおすすめの仕組みとなる。Wi-Fiの認証にも対応しているので、LANケーブルすら不要にもできる。\n\n あとはmicroSDカードに書き込んで、Raspberry Pi 4に接続し、電源を入れるだけで良い。今回は初期設定時にavahi-daemonをインストールするために、あらかじめLANケーブルも接続しておく。\n\n 電源を入れたあとは自動的な初期設定が動く。しばらく待ってから、SSHログインを試みてみよう。次のような方法でavahi-daemonが立ち上がるのを待っても良いかもしれない。\n\npingが成功したら準備完了ということで成功するまで待ち続ける。Ctrl-Cで中断できる\n$ while true; do if ping -q -c 1 ホスト名.local; then break; fi; sleep 1; done\n\n microSDを使っている場合、Ubuntuサーバーだと起動完了に1分から2分ぐらいかかる。さらに初回起動時はいろいろな初期化処理が動くので、だいたい10分経ってもpingに応答がなければ何か問題があると考えれば良いだろう。その場合は、HDMIとキーボードを接続するかシリアルコンソールを接続することになる。\n\n ちなみにログインしたあとに次のコマンドを実行すると、cloud-initが正常に終了しているかを確認できる。\n\n「SUCCESS」と表示されていたら基本的に成功。初回起動時の処理に6分ぐらいかかっていることが分かる\n$ tail -n 3 /var/log/cloud-init.log\n2024-08-31 10:14:56,419 - util.py[DEBUG]: Read 14 bytes from /proc/uptime\n2024-08-31 10:14:56,419 - util.py[DEBUG]: cloud-init mode 'modules' took 358.360 seconds (358.36)\n2024-08-31 10:14:56,419 - handlers.py[DEBUG]: finish: modules-final: SUCCESS: running modules for final\n\n インストールが完了し、ログインできたらシステムを更新しておこう。\n\nUbuntu 24.04 LTSでは「-U」オプションを付けると事前にapt updateをやってくれる\n$ sudo apt -U -y full-upgrade\n\n さらにEEPROMも更新しておくことをおすすめする。\n\nあまりに古いEEPROMだとUSBブートなどもうまく動かないので注意が必要だ\n$ sudo rpi-eeprom-update -a\n*** PREPARING EEPROM UPDATES ***\n\nBOOTLOADER: update available\nCURRENT: Tue Jan 25 14:30:41 UTC 2022 (1643121041)\nLATEST: Wed Jan 11 17:40:52 UTC 2023 (1673458852)\nRELEASE: default (/lib/firmware/raspberrypi/bootloader-2711/default)\nUse raspi-config to change the release.\n\nVL805_FW: Using bootloader EEPROM\nVL805: up to date\nCURRENT: 000138a1\nLATEST: 000138a1\nCURRENT: Tue Jan 25 14:30:41 UTC 2022 (1643121041)\nUPDATE: Wed Jan 11 17:40:52 UTC 2023 (1673458852)\nBOOTFS: /boot/firmware\n'/tmp/tmp.EU69Yi2DSx' -＞ '/boot/firmware/pieeprom.upd'\nCopying recovery.bin to /boot/firmware for EEPROM update\n\nEEPROM updates pending. Please reboot to apply the update.\nTo cancel a pending update run ""sudo rpi-eeprom-update -r"".\n\n ちなみにRaspberry Piの温度は次の方法で確認できる。ファンありのケースだとかなり温度は抑えめだ。\n\nパッケージ更新処理直後にこれぐらいなら高温時以外はファンをオフにする仕組みを実装してもいいかもしれない\n$ vcgencmd measure_temp\ntemp=33.6'C\n\n あとはシステムを再起動して、Raspberry Piの準備は完了となる。\n\n■ Jellyfinをインストール\n\n ようやくJellyfinをインストールする準備が整ったので、インストールしていこう。Jellyfinにはさまざまなインストール方法が存在するが、Ubuntuの場合はインストールスクリプトを使うのが一番楽だろう。これはJellyfinが提供するパッケージリポジトリを追加するため、ソフトウェアのアップデートもaptコマンドで実行できる。\n\n まずインストールスクリプト(install-debuntu.sh)をダウンロードして、ハッシュ値が合っているか比較しよう。\n\n特に何も表示されなければ問題ないことになる\n$ diff ＜( curl -s https://repo.jellyfin.org/install-debuntu.sh -o install-debuntu.sh; sha256sum install-debuntu.sh ) ＜( curl -s https://repo.jellyfin.org/install-debuntu.sh.sha256sum )\n$ （この手前でエラーなどが表示されなければOK）\n\n ダウンロードしたinstll-debuntu.shを実行する前に、それが何をするかは確認しておこう。アーキテクチャやOSに依存するものの、基本的にはJellyfinのリポジトリを追加し、Jellyfinとそれが依存するパッケージをインストールしている。Jellyfinパッケージがインストールされたら、自動的にサービスが立ち上がるので、そのアクセス手順も表示するスクリプトだ。\n\nインストールスクリプトを実行して、Jellyfinパッケージをインストールする\n$ sudo bash install-debuntu.sh\n＞ Determining optimal repository settings.\n\nFound the following details from '/etc/os-release':\nReal OS:ubuntu\nRepository OS:ubuntu\nRepository Release: noble\nCPU Architecture:arm64\nIf this looks correct, press ＜Enter＞ now to continue installing Jellyfin.\n（中略）\n＞ Installing Jellyfin repository into APT.\nTypes: deb\nURIs: https://repo.jellyfin.org/ubuntu\nSuites: noble\nComponents: main\nArchitectures: arm64\nSigned-By: /etc/apt/keyrings/jellyfin.gpg\n（中略）\n＞ Waiting 15 seconds for Jellyfin to fully start up.\n\n-------------------------------------------------------------------------------\n● jellyfin.service - Jellyfin Media Server\nLoaded: loaded (/usr/lib/systemd/system/jellyfin.service; enabled; preset: enabled)\nDrop-In: /etc/systemd/system/jellyfin.service.d\n└─jellyfin.service.conf\nActive: active (running) since Sun 2024-08-18 17:30:02 JST; 27s ago\n（中略）\nYou should see the service as 'active (running)' above. If not, use https://jellyfin.org/contact to find us for troubleshooting.\n\nYou can access your new instance now at http://192.168.10.11:8096 in your web browser to finish setting up Jellyfin.\n\nThank you for installing Jellyfin, and happy watching!\n\n 最後の方で「Active: (active (running)」になっていたら問題ない。その後、最後のほうにある「http://IPアドレス:8096」もしくは「http://ホスト名.local:8096」にWebブラウザからアクセスしよう。あとは次のように初期設定を行なうことになる。\n\n 「自動ポートマッピングを有効」すると、自宅のJellyfinに外出先からアクセスできるようになる。ただしもちろんIPアドレスなどを何らかの方法で知らなくてはならないし、そのコンテンツが本当にインターネット経由で再生できるかどうかも、コンテンツに依存する。まずはローカルで使ってみる前提で、「自動ポートマッピングを有効」はオフにしておこう。\n\n 本来は、ここで次のステップとしてメディアライブラリを追加することになる。ただし今回は前述したように、「Raspberry Piに接続したUSBストレージ」をメディアライブラリとして使用したい。そこでまずはUSBストレージを追加する方法を紹介しよう。\n\n■ 外部ストレージの設定\n\n それではメディアデータを保存するためのUSBストレージを設定しよう。\n\n ちなみにUSBストレージである必要性はない。同じネットワーク上にいるNASのストレージをNFSやSambaでマウントして参照しても良いし、Raspberry Pi自体をNASとして運用することも可能だ。NextcloudやGoogle Driveのようなオンラインストレージをローカルにマウントして同期をとってもかまわない。Jellyfinからはローカルファイルとしてメディアデータが見えれば良いので、環境に応じてさまざまな組み合わせが考えられる。\n\n その中でもっともシンプルなのが、「USBストレージ上のメディアを再生する」というわけだ。USBストレージをUbuntu上で使うにはまず最初にファイルシステムについて検討する。\n\n・FATやNTFSを使う\n・ext4などでフォーマットする\n\n USBストレージは購入時点で大抵はFATやNTFSなど、Windowsからすぐにアクセスできるファイルシステムでフォーマットされているはずだ。それをそのままUbuntuで使っても良い。その場合は後述のフォーマットはスキップできる。ただ1個あたりのファイルサイズが大きかったり、ファイルの数が増えてくるなら、Ubuntu上でよく使われているext4などのファイルシステムを使ったほうが安定するし、高速できもある。せっかくなのでUSBストレージを、ext4でフォーマットする方法も紹介しておこう。\n\n Ubuntuデスクトップがあるなら、そちらでGUIからフォーマットしても良いが、CLIなら次の手順となる。まずUSBストレージをRasyberry Piに接続する。するとdmesgに次のようなログが現れる。\n\ndmesgはカーネルのログメッセージを表示するコマンドだ\n$ sudo dmesg | tail\n[ 8913.851032] sd 1:0:0:0: Attached scsi generic sg1 type 0\n[ 8914.354926] sd 1:0:0:0: [sdb] 976773168 512-byte logical blocks: (500 GB/466 GiB)\n[ 8914.354962] sd 1:0:0:0: [sdb] 4096-byte physical blocks\n[ 8914.355155] sd 1:0:0:0: [sdb] Write Protect is off\n[ 8914.355177] sd 1:0:0:0: [sdb] Mode Sense: 5f 00 00 08\n[ 8914.355583] sd 1:0:0:0: [sdb] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA\n[ 8914.356078] sd 1:0:0:0: [sdb] Preferred minimum I/O size 4096 bytes\n[ 8914.356103] sd 1:0:0:0: [sdb] Optimal transfer size 33553920 bytes not a multiple of preferred minimum block size (4096 bytes)\n[ 8914.361677]sdb: sdb1 sdb2 sdb3\n[ 8914.363698] sd 1:0:0:0: [sdb] Attached SCSI disk\n\n 上記の例だと「sdb」が接続されたストレージだということが分かる。環境によって「sda」だったり「sdc」だったり「mmcblk0」だったり「nvme0n1」だったりするので注意が必要だ。今回は比較的シンプルな手順を説明したが、ログを読める知識が必要という難点もある。もう少しカジュアルにやるなら、ストレージ接続前にlsblkコマンドを実行し、接続後にもう一度実行して、その差を確認するとかだろうか。これはこれで泥臭い気もする。\n\n さて「sdb」がストレージだと分かったので、あとはフォーマットしていこう。まずはGPTパーティションテーブルに変更して、ストレージすべてをひとつのパーティションにする。\n\n「/dev/sdb」は環境に応じて変更する必要がある。間違えると大事なデータが消えて大惨事になるので注意して操作して欲しい\n$ sudo parted /dev/sdb\nGNU Parted 3.6\nUsing /dev/sdb\nWelcome to GNU Parted! Type 'help' to view a list of commands.\n\nGPTに変更する：\n(parted) mklabel gpt\nWarning: The existing disk label on /dev/sdb will be destroyed and all data on this disk will be lost. Do you want to continue?\nYes/No? y\nError: Partition(s) 3 on /dev/sdb have been written, but we have been unable to inform the kernel of the change, probably because it/they are in use.As a result, the old partition(s) will remain in use.\nYou should reboot now before making further changes.\nIgnore/Cancel? i\n\n第一パーティションにすべての領域を使う：\n(parted) mkpart primary ext4 0% 100%\nError: Partition(s) 1, 3 on /dev/sdb have been written, but we have been unable to inform the kernel of the change, probably because it/they are in use.As a result, the old partition(s) will remain in use.\nYou should reboot now before making further changes.\nIgnore/Cancel? i\n\n変更結果を表示する：\n(parted) print\nModel: I-O DATA SSPS-US (scsi)\nDisk /dev/sdb: 500GB\nSector size (logical/physical): 512B/4096B\nPartition Table: gpt\nDisk Flags:\n\nNumberStartEndSizeFile systemNameFlags\n11049kB500GB500GBext4primary\n\n(parted) quit\nInformation: You may need to update /etc/fstab.\n\n 個別にいろいろメッセージが出たり、確認事項が出てくるがすべてYesかIgnoreで問題ない。特に「Ignore/Cancel」についてはパーティションテーブルが変更されたことで、カーネル側の情報を更新する必要がある旨の警告であり、今回はこの時点では無視して良い。ただし「quit」したあとに次のコマンドで情報を更新しておこう。\n\nパーティションテーブルの最新情報をカーネルに反映する\n$ sudo partprobe /dev/sdb\n\n ちなみにここではインタラクティブに設定したが、次のようなコマンドで一気にやってしまうという手もある。\n\nあらかじめ設定したい内容が決まっているならコマンドのオプションに設定してあげれば良い\n$ sudo parted -s /dev/sdb mklabel gpt\n$ sudo parted -s /dev/sdb -- mkpart primary 0% 100%\n\n 次はファイルシステムのフォーマットだ。\n\next4ファイルシステムとしてフォーマットする\n$ sudo mkfs -t ext4 /dev/sdb1\nmke2fs 1.47.0 (5-Feb-2023)\n/dev/sdb1 contains a vfat file system\nProceed anyway? (y,N) y\n（中略）\nWriting superblocks and filesystem accounting information: done\n\n 最後にファイルシステムのUUIDを確認しておこう。\n\nUUID=がファイルシステムのUUIDで、PARTUUIDはパーティションのUUID\n$ sudo blkid /dev/sdb1\n/dev/sdb1: UUID=""4247cd06-3f16-419b-bdb7-aae0abfa6177"" BLOCK_SIZE=""4096"" TYPE=""ext4"" PARTLABEL=""primary"" PARTUUID=""c7ea04c3-76ec-4d38-9d67-51744a7cedb1""\n\n これでストレージの準備は整った。ただ、どうせならUSBストレージが接続されているときは自動的にマウントされるようにしておきたい。そこでマウント用のエントリを作成し、デバイスを認識したら自動的にマウントするように設定しよう。\n\n マウント用のエントリについてはいろいろな案があるが、リムーバブルメディアであれば「/media」以下にディレクトリを作ってマウントさせることが一般的だ。今回は「/media/jellyfin」というディレクトリを作っておくことにする。\n\nマウント用のエントリの作成\n$ sudo mkdir /media/jellyfin\n\n 次に「sudo editor /etc/fstab」を実行して、fstabを編集する。これはシステムがファイルシステムをマウントする際の情報を記録しているファイルだ。ここに書いておけば、あるストレージをどこのマウント用エントリにどのようなオプションでマウントするかを管理できる。すでにルートファイルシステムなどが記載されているはずなので、末尾に新しい行を追加しよう。\n\n末尾に次の行を追加する\nUUID=（blkidで表示したUUIDの値） /media/jellyfin ext4 defaults,noauto,x-systemd.automount 0 0\n\n ポイントは「noauto」と「x-systemd.automount」だ。「noauto」は自動マウントしないオプションだ。たとえばこれが設定されていないと、システムは起動時にマウントしにいこうとする。リムーバブルメディアの場合、起動時に必ずしもデバイスが繋がっているとは限らないため、マウントに失敗する可能性がある。マウントに失敗するとそこで緊急モードに遷移してしまうため、ディスプレイとキーボードを繋いで復旧させなくてはならなくなるのだ。\n\n 「x-systemd.automount」はデバイスを認識したら自動的にマウントするsystemdの機能だ。noautoと組み合わせて使うことで、起動時にデバイスがあればマウントするし、なければ何もしないといった動作にできる。今回の用途にはぴったりだろう。\n\n 設定が終わったら最後にマウントしてメディアを保存するディレクトリを作ってしまおう。\n\nfstabを更新した場合は、systemd daemon-reloadも実行しておこう。大抵の場合は必須ではないが、mountコマンド側の警告を抑制できる。今回はx-systemd.automountを設定しているのでやっておいたほうが良い\n$ sudo systemd daemon-reload\n$ sudo mount /media/jellyfin\n$ sudo chown $USER: /media/jellyfin\n$ mkdir /media/jellyfin/Music\n\n 今回は手持ちの楽曲を保存したかったので「Music」というディレクトリを作っておいた。あとはここにJellyfinで再生したいファイルを置いておく。\n\n さて、ここまで読んで「めんどくさい！」と思ったそこのあなた。その感覚は正しい。LinuxのCLIに慣れたユーザーであれば手癖で覚えていることも多いものの、たまにしかやらない場合は「あれここはどうするのが正しい手順だっけ？」と悩むことも多い。普段CLIに慣れてない人なら、さらにめんどくさそうに思えるだろう。\n\n ただし、そこまで何度もやる手順ではないこと、汎用性が高いため一度慣れてしまえば他の環境でも流用可能なこと、実際に実施した操作をコマンド履歴として残せること、ころころ変わりがちなGUIの操作には依存しなくて良く、場合によっては「コピペ」ですべて完了することなどから、CLIの操作を好む人も多い。\n\n せっかくRaspberry Piをディスプレイとキーボードが不要なヘッドレスで運用する機会なので、これを機にCLIにも手を出してみよう。\n\n■ メディアライブラリを追加する\n\n ストレージにメディアを用意できたら、Jellyfin側の操作に戻る。\n\n UIは丁寧に日本語化されているため、操作につまずくことはほぼないだろう。プレイリストなども作成/編集できるので、そちらも活用すると良い。\n\n■ Jellyfin専用のクライアントを用意する\n\n JellyfinにはWeb UIだけでなく、専用のクライアントも用意されている。また初期設定では無効化されているが、DLNAにも対応しているためDMPを使うという手もある。\n\n DLNAについては「ダッシュボード」の「管理」から「DLNA」を選択し、「プラグインを取得」を選べば使えるようになる。ただし、プラグイン化されていることからも想像できるように、Jellyfin本体としてはDLNA対応にはあまり積極的でない。普通のTVにような専用クライアントを入れられないような環境向けだと考えておこう。\n\n さて、前述のとおりJellyfinでは各プラットフォーム向けに専用クライアントを提供している。もちろんUbuntu向けも存在する。一番簡単にインストールできるのはFlatpak版のクライアントだろう。Flatpakについては第4回で軽く紹介しているが、どのLinuxディストリビューションでも使えるパッケージフォーマットだと考えておけば良い。一応GitHub側にDebianパッケージ版も用意されているが、アップデートの追随が面倒になるのでFlatpakのほうをおすすめする。\n\n UbuntuにFlatpakパッケージをインストールするには、管理用ソフトウェアをインストールし、リポジトリを追加する必要がある。\n\nFlatpakパッケージインストールのための準備\n$ sudo apt install flatpak\n$ flatpak remote-add --if-not-exists flathub https://flathub.org/repo/flathub.flatpakrepo\n\n あとは追加したリポジトリからパッケージをインストールするだけだ。\n\nFlatpakのパッケージはぱっと見、わかりにくい。本来はGUIからインストールする想定であるのも理由の1つだ\n$ flatpak install flathub com.github.iwalton3.jellyfin-media-player\nLooking for matches…\nRequired runtime for com.github.iwalton3.jellyfin-media-player/x86_64/stable (runtime/org.kde.Platform/x86_64/5.15-23.08) found in remote flathub\nDo you want to install it? [Y/n]:（Enterを入力）\n\ncom.github.iwalton3.jellyfin-media-player permissions:\n（使用する権限が表示される）\n\n（中略）\n\n パッケージの起動はSuperキー(Windowsキー)を押して、「jellyfin」で検索すれば良い。また端末からも以下の方法で起動できる。\n\nパッケージ名を指定して、flatpakコマンド経由で起動する\n$ flatpak run com.github.iwalton3.jellyfin-media-player\n\n 最初はJellyfinサーバーへ接続する。ここで注意しなくてはならないのが、Flatpakパッケージ版だとAvahi/mDNSが動かないことだ。つまり「ホスト名.local」のような名前解決ができず、DNSを使うかIPアドレスを直接入力する必要がある。\n\n 一度ログインしてしまえば、使い方自体はWeb版のそれとほぼ同じとなる。Webブラウザが良いか、専用クライアントが良いかは好みに合わせれば良いだろう。スマートフォン/スマートTV向けのクライアントも用意されているので、そちらもぜひ試してみて欲しい。\n\n ちなみにRaspberry Pi 4上で楽曲を再生しているだけなら、CPUを10%も使用しない。CPU温度もケースのファンを静音モードで回していても40℃前後を行ったり来たりする程度だ。\n\n 今回はとりあえず「インストールして使えるようにする」までを紹介したが、実際はここからさらにカスタマイズする方法がいくつかある。たとえばどうせRaspberry Pi上に楽曲データがあるなら、USBスピーカーやBluetoothオーディオデバイスもそちらに繋げてしまって、そこから音を流してみたいと思うかもしれない。残念ながらJellyfin単体では実現できないが、JellyfinをYouTube Musicのような音楽ストリーミングサービスとして捉えて、そういうクライアントを使えばできそうだ。\n\n また今回はmicroSDカードにUbuntu本体をインストールしたが、microSDカードはそこまで耐久性は高くない。少しでも耐久性を上げたければ、「書き込み回数を減らす」のが一番お手軽な方法だ。よく使われるのは「overlayfs」だろう。これは複数のファイルシステムを重ねて1つのファイルシステムに見せる仕組みで、Dockerなどでも使用されている。microSDカード上のファイルシステムを下のレイヤーにし、そこにメモリ上に作成したファイルシステムをかぶせることでファイルシステムへの書き込みはすべてメモリにのみ行われる。これによりmicroSDカードへの書き込みを減らせる。\n\n これは再起動するとデータが消えることを意味する。よってログを別の書き込み可能で壊れても良いストレージに保存したり、いっそのことログは諦めてしまうということも考えなくてはならず、メリットばかりではないものの有力な手段と言えるだろう。これはUbuntuでも可能なので、ぜひチャレンジしてみて欲しい。\nPC Watch,Ubuntu Japanese Team/株式会社 創夢 柴田充也",['https://newsatcl-pctr.c.yimg.jp/t/amd-img/20240921-00000015-imppcw-000-1-view.jpg?exp=10800'],"['https://news.yahoo.co.jp/articles/5c2bc36acea521b3955a2cb94837f00b393fabd5/images/000', 'https://pc.watch.impress.co.jp/img/pcw/docs/1625/361/html/02.png.html', 'https://news.yahoo.co.jp/search?p=%23%E3%82%92%E6%8E%A1%E7%94%A8%E3%81%97%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8C&source=article-body']"
